# 09 — کالیبراسیون و مقیاس واقعی در AR
> هدف این فصل: هرآنچه برای **ثبت مقیاس واقعی** بین دادهٔ فیزیکی (میلی‌متر/سانتی‌متر) و جهان AR (متر) لازم است—از روش‌های کالیبراسیون تا پیاده‌سازی گام‌به‌گام در Unity/AR Foundation و کنترل خطاها. این فصل **عمومی** است و به اپلیکیشن خاصی ارجاع نمی‌دهد.

- **چکیده:** جهان AR عموماً با **متر** کار می‌کند، اما دادهٔ فیزیکی شما اغلب **میلی‌متر** است. کالیبراسیون یعنی یافتن یک **نسبت تبدیل پایدار** و استفادهٔ سازگار از آن در تمام رندرها/محاسبات. روش‌های عملی شامل **دو-نقطهٔ مرجع با فاصلهٔ معلوم**، **شیء مرجع با اندازهٔ معلوم** و **نشانگر تصویری با ابعاد معلوم** است.
- **پس از مطالعه:** می‌توانید یک سناریوی کالیبراسیون انتخاب کنید، پیاده‌سازی کنید، دقت را بسنجید، خطا را مدل کنید و مقیاس را ذخیره/بازگردانی کنید.

---

## 1) مفاهیم و فرمول پایه
- **واحد جهان AR (Unity):** 1.0 = **۱ متر**  
- **دادهٔ فیزیکی:** اغلب **میلی‌متر (mm)** یا **سانتی‌متر (cm)**  
- **نسبت تبدیل:**  
  - `meters_per_mm = measured_distance_m / true_distance_mm`  
  - `meters_per_cm = measured_distance_m / true_distance_cm`  
- **تبدیل ابعاد شیء:**  
  - `world_m = real_mm * meters_per_mm`  
  - `real_mm = world_m / meters_per_mm`

> به‌جای تغییر مقیاس «جهان»، **مقیاس اشیای خود** را با نسبت فوق تنظیم کنید (پایدارتر و قابل‌کنترل‌تر است).

---

## 2) روش‌های کالیبراسیون
### 2.1 دو-نقطهٔ مرجع با فاصلهٔ معلوم (Two-Point)
1) کاربر دو نقطهٔ مرجع را در محیط لمس می‌کند.  
2) شما با **Raycast → Anchor**، جای دو نقطه را در جهان می‌یابید.  
3) فاصلهٔ سه‌بعدی بین نقاط (`d_m`) را می‌سنجید.  
4) فاصلهٔ واقعی (`D_mm`) را از کاربر/اسناد دارید.  
5) `meters_per_mm = d_m / D_mm`

**مزایا:** سریع، شهودی. **ریسک:** انتخاب نقاط روی سطوح نامعتبر/زاویه‌دار خطا ایجاد می‌کند.

### 2.2 هم‌ترازکردن یک شیء مرجع با اندازهٔ معلوم
- یک «جعبهٔ مجازی»/Proxy با ابعاد قابل‌تنظیم را روی شیء واقعی منطبق کنید؛ با اسلایدر یا Pinch اندازه را تا هماهنگی کامل تنظیم کنید → نسبت تبدیل به‌دست می‌آید.
- **مزایا:** بدون اندازه‌گیری دستی فاصله. **ریسک:** وابسته به قضاوت بصری کاربر.

### 2.3 نشانگر تصویری با ابعاد معلوم (Image Marker)
- از **Image Tracking** (AR Foundation) استفاده کنید؛ ابعاد فیزیکی تصویر (مثلاً A4: 210×297 mm) را از قبل تعیین می‌کنید؛ Pose/Scale مارکر به شما مرجع می‌دهد.
- **مزایا:** تکرارپذیر و دقیق در محیط‌های مناسب. **ریسک:** نیازمند چاپ/نصب نشانگر و نور/بافت مناسب.

> اگر چند روش قابل‌اجرا است، **میانگین وزنی** چند اندازه‌گیری بگیرید و انحراف معیار را ذخیره کنید (اعتماد بالاتر).

---

## 3) پیاده‌سازی دو-نقطه‌ای در Unity (AR Foundation)
### 3.1 اسکریپت نمونه: ثبت دو نقطه و محاسبهٔ نسبت
```csharp
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR.ARFoundation;
using UnityEngine.XR.ARSubsystems;

public class TwoPointCalibrator : MonoBehaviour
{
    public ARRaycastManager raycastManager;
    public ARAnchorManager anchorManager;
    public TrackableType trackables = TrackableType.PlaneWithinPolygon;

    public float metersPerMm { get; private set; } = 0.001f; // پیش‌فرض 1mm=1e-3m
    public bool IsCalibrated => _count == 2;

    static readonly List<ARRaycastHit> hits = new();
    ARAnchor _a, _b;
    int _count = 0;

    public void ResetCalib()
    {
        if (_a) Destroy(_a.gameObject);
        if (_b) Destroy(_b.gameObject);
        _a = _b = null;
        _count = 0;
    }

    // صدا بزنید وقتی کاربر روی صفحه تپ می‌کند
    public void OnTap(Vector2 screenPos, float trueDistanceMm)
    {
        if (!raycastManager.Raycast(screenPos, hits, trackables)) return;
        var hit = hits[0];
        var plane = hit.trackable as ARPlane;
        if (plane == null) return;

        var anchor = anchorManager.AttachAnchor(plane, hit.pose);
        if (_count == 0) { _a = anchor; _count = 1; return; }
        if (_count == 1) { _b = anchor; _count = 2; ComputeScale(trueDistanceMm); }
    }

    void ComputeScale(float trueDistanceMm)
    {
        if (_a == null || _b == null || trueDistanceMm <= 0) return;
        float dMeters = Vector3.Distance(_a.transform.position, _b.transform.position);
        metersPerMm = dMeters / trueDistanceMm;
        Debug.Log($"[Calib] meters_per_mm = {metersPerMm:F6} (d={dMeters:F3}m / D={trueDistanceMm:F1}mm)");
    }
}
```

### 3.2 استفادهٔ ایمن از نسبت تبدیل
- یک **CalibrationContext** (ScriptableObject یا کلاس Singleton) نگه دارید که فقط یک منبع حقیقت برای `metersPerMm` باشد.
- همهٔ سازنده‌های «جعبه/مدل/اندازه‌گیری» باید از همین نسبت استفاده کنند.

```csharp
public static class Units
{
    public static float metersPerMm = 0.001f; // مقدار پیش‌فرض
    public static float ToMetersFromMm(float mm) => mm * metersPerMm;
    public static float ToMmFromMeters(float m) => m / metersPerMm;
}
```

> **اصل سازگاری:** یک نسبت، همه‌جا. از تبدیل‌های پراکنده/متناقض بپرهیزید.

---

## 4) کالیبراسیون با شیء مرجع (Proxy Alignment)
1) یک **Box Proxy** با Scale قابل‌تنظیم بسازید (World-space).  
2) کاربر آن را به‌صورت بصری روی شیء واقعی منطبق می‌کند (Drag/Pinch/Rotate).  
3) با دانستن `size_mm_real` و `size_m_world_current`، نسبت تبدیل را محاسبه/به‌روزرسانی کنید.  
4) برای کاهش نویز، از چند بُعد/زاویه نمونه بگیرید و میانگین بگیرید.

**نمونهٔ محاسبه:**
```
meters_per_mm = size_m_world_current / size_mm_real
```

---

## 5) کالیبراسیون با نشانگر تصویری (Image Tracking)
- یک Reference Image با **عرض/ارتفاع واقعی** تعریف کنید (کتابخانهٔ تصاویر مرجع).  
- وقتی تصویر شناسایی شد، Pose و Scale آن را دریافت می‌کنید.  
- اگر موتور ردیابی Scale را نرمال‌سازی کند، از ابعاد تعریف‌شده به‌عنوان منبع حقیقت استفاده کنید و از Pose برای جای‌گذاری/هم‌ترازی کمک بگیرید.

**نکات:** نور یکنواخت، کنتراست تصویر، پرهیز از بازتاب/چین‌خوردگی کاغذ.

---

## 6) اعتبارسنجی پس از کالیبراسیون
### 6.1 آزمون «خط‌کش دوم»
- یک فاصله/شیء **غیرواردشده** با اندازهٔ معلوم را اندازه بگیرید و **خطای نسبی** را محاسبه کنید:
```
relative_error = |measured_m - true_m| / true_m
```
- **آستانهٔ پیشنهادی:** برای موبایل‌های معمولی، `relative_error ≤ 3%` خوب، `≤ 1.5%` عالی.

### 6.2 رنگ‌بندی دقت
| خطای نسبی | وضعیت |
|---|---|
| ≤ 1% | عالی (سبز) |
| 1–3% | خوب (سبز روشن) |
| 3–5% | قابل‌قبول (زرد) |
| > 5% | نیاز به تکرار کالیبراسیون (قرمز) |

---

## 7) مدل خطا و کاهش آن
| منبع خطا | توضیح | راهکار |
|---|---|---|
| انتخاب نقاط نامعتبر | روی لبه/مرز Plane یا سطح مورّب | چک زاویهٔ نرمال؛ فاصله از مرز؛ پیام راهنما |
| لرزش دست/حرکت سریع | نویز در Pose | درخواست «حرکت آرام»؛ نمونه‌گیری چندباره و میانگین |
| نور کم/زیاد | افت کیفیت Tracking | افزایش نور یکنواخت؛ تغییر زاویه دوربین |
| سطوح براق/شفاف | بازتاب/شکست | استفاده از سطوح مات؛ تغییر محل نمونه |
| ادغام/تغییر Plane | پرش Pose | بعد از تأیید، Anchor پایدار بسازید |
| خطای عددی | گرد کردن/دقت پایین | نمایش با 3–4 رقم معنادار؛ ذخیره با دقت کافی |

**میانگین‌گیری چندباره (نمونه):**
```csharp
List<float> samples = new();
float MetersPerMmMean() => samples.Count==0 ? 0.001f : samples.Average();
float StdDev() { var m=MetersPerMmMean(); return Mathf.Sqrt(samples.Sum(x=> (x-m)*(x-m)) / Mathf.Max(1,samples.Count-1)); }
```

---

## 8) هم‌ترازی محورها و چارچوب‌ها
- **نرمال Plane** را به‌عنوان محور «بالا/پایین» محلی در نظر بگیرید.
- جهت‌گیری اشیاء را نسبت به محورهای Plane تنظیم کنید (چرخش حول نرمال).  
- برای جلوگیری از «چرخیدگی‌های ناخواسته»، از **Snap زاویه‌ای** (مثلاً به مضارب ۱۵°) استفاده کنید.

---

## 9) ذخیره و بازیابی مقیاس
- نسبت تبدیل را در فایل تنظیمات (JSON) یا `PlayerPrefs` ذخیره کنید.
- همراه نسبت، **تاریخ/روش/اعتماد** را نگه دارید.

نمونهٔ JSON:
```json
{
  "calibration": {
    "method": "two_point",
    "meters_per_mm": 0.00104,
    "samples": 3,
    "stdev": 0.00002,
    "ts": "2025-09-14T10:30:00Z"
  }
}
```

**قواعد:**  
- در هر اجرا صحت را با یک آزمون سریع بسنجید (اختیاری).  
- امکان «Reset Calibration» ارائه دهید.  

---

## 10) رابط کاربری پیشنهادی (الگوهای عمومی)
- **Wizard کوتاه**: «نقطه اول را لمس کنید» → «نقطه دوم را لمس کنید» → «فاصلهٔ واقعی را وارد/تأیید کنید» → «نتیجه/دقت».
- نمایش **پیشرفت** و **اعتماد** (bars/labels).  
- دکمه‌های واضح: **تکرار**، **تأیید**، **بازنشانی**.

نمونهٔ متن‌ها (JSON):
```json
{
  "calib": {
    "title": "کالیبراسیون",
    "tap_first": "نقطهٔ اول را لمس کنید",
    "tap_second": "نقطهٔ دوم را لمس کنید",
    "enter_distance": "فاصلهٔ واقعی را وارد کنید (میلی‌متر)",
    "result": "نسبت تبدیل: {value} m/mm • خطا: {err}%",
    "repeat": "تکرار",
    "confirm": "تأیید"
  }
}
```

---

## 11) سنجش ادراکی: فریب پرسپکتیو و FoV
- اشیای نزدیک **بزرگ‌تر** دیده می‌شوند؛ برای قضاوت بصری از **سایهٔ تماس** و **شبکهٔ مقیاس‌دار** کمک بگیرید.
- **FoV** دوربین‌های مختلف متفاوت است؛ نشانگرهای دیداری را برای هدایت کاربر استفاده کنید (مثلاً «به اندازهٔ یک بازو فاصله بگیرید»).

---

## 12) نکات پلتفرمی/سخت‌افزاری (کوتاه)
- دستگاه‌هایی با **LiDAR/ToF** در کشف سطوح و پایداری، مزیت دارند؛ اما همیشه موجود نیستند.
- روی چند دستگاه با **سنسور/دوربین متفاوت** تست کنید؛ تفاوت FoV/اکسپوژر اثرگذار است.

---

## 13) چک‌لیست اجرای کالیبراسیون
- [ ] روش مناسب انتخاب شده (دو-نقطه / شیء مرجع / نشانگر تصویری).
- [ ] محیط مناسب (نور یکنواخت، سطح مات، بافت کافی).
- [ ] UI راهنما و پیام‌های واضح.
- [ ] نمونه‌گیری ≥ 2–3 بار و میانگین‌گیری (اختیاری).
- [ ] اعتبارسنجی با مرجع دوم و محاسبهٔ خطا.
- [ ] ذخیرهٔ نسبت، زمان و اعتماد؛ قابلیت Reset.

---

## 14) نکات کلیدی فصل
- **یک نسبت تبدیل پایدار** قلب مقیاس واقعی در AR است؛ آن را یک‌بار محکم بسازید و همه‌جا از همان استفاده کنید.
- روش **دو-نقطه** سریع و عمومی است؛ نشانگر تصویری برای تکرارپذیری خوب است؛ هم‌ترازی Proxy برای سناریوهای بدون ابزار اندازه‌گیری مناسب است.
- **اعتبارسنجی و مدل خطا** را جدی بگیرید؛ ۱–۳% خطا هدف خوبی روی موبایل است.
- دقت نهایی تابع **نور/بافت/زاویه** و **رفتار کاربر** است—راهنمایی واضح بدهید.
