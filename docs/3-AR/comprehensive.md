# ویکی جامع واقعیت افزوده (AR) — برای تازه‌کارها

> **توضیح:** این سند یک مرجع آموزشی و عملی است برای کسانی که می‌خواهند از صفر وارد دنیای واقعیت افزوده شوند. ساختار بر پایهٔ ۲۸ بخش تنظیم شده و شامل مفاهیم، راه‌اندازی، نمونه‌کدها، روش‌های چیدمان و نکات عملی است. پروژه‌ یا نمونهٔ شما فقط به‌عنوان مثال در بخش‌های مرتبط اشاره می‌شود؛ تمرکز اصلی بر آموزش عمومی است.

---

## فهرست (Contents)

1. [مقدمه و تعاریف](#1-مقدمه-و-تعاریف)
2. [تاریخچه مختصر و مسیر توسعه](#2-تاریخچه-مختصر-و-مسیر-توسعه)
3. [تفاوت AR، VR و MR](#3-تفاوت-ar-vr-و-mr)
4. [انواع روش‌های AR](#4-انواع-روش‌های-ar)
5. [موارد استفاده (Use Cases)](#5-موارد-استفاده-use-cases)
6. [پیش‌نیازها و مهارت‌های لازم](#6-پیش‌نیازها-و-مهارتهای-لازم)
7. [سخت‌افزارها و سنسورها](#7-سختافزارها-و-سنسورها)
8. [نرم‌افزارها، موتور‌ها و کتابخانه‌ها](#8-نرم‌افزارها-موتورها-و-کتابخانهها)
9. [مفاهیم پایه فنی](#9-مفاهیم-پایه-فنی)
10. [معماری یک اپلیکیشن AR](#10-معماری-یک-اپلیکیشن-ar)
11. [راه‌اندازی محیط توسعه: Unity + AR Foundation (گام‌به‌گام)](#11-راهاندازی-محیط-توسعه-unity--ar-foundation-گامبهگام)
12. [نمونه‌کدها و الگوهای طراحی (C# برای Unity)](#12-نمونهکدها-و-الگوهای-طراحی-c-برای-unity)
13. [مدیریت محتوا و مدل‌های سه‌بعدی](#13-مدیریت-محتوا-و-مدلهای-سهبعدی)
14. [طراحی تجربه کاربری (UX) برای AR](#14-طراحی-تجربه-کاربری-ux-برای-ar)
15. [الگوریتم‌های مکان‌یابی و نقشه‌برداری (SLAM و موارد مرتبط)](#15-الگوریتمهای-مکانیابی-و-نقشهبرداری-slam-و-موارد-مرتبط)
16. [تشخیص سطوح (Plane Detection)، لنگرها (Anchors) و Raycasting](#16-تشخیص-سطوح-plane-detection-لنگرها-anchors-و-raycasting)
17. [اوکلوژن (Occlusion) و برآورد نور (Light Estimation)](#17-اوکلوژن-occlusion-و-برآورد-نور-light-estimation)
18. [کار با LiDAR و داده‌های عمق (Depth)](#18-کار-با-lidar-و-دادههای-عمق-depth)
19. [بهینه‌سازی عملکرد و ملاحظات حافظه](#19-بهینهسازی-عملکرد-و-ملاحظات-حافظه)
20. [تست، دیباگ و مستندسازی](#20-تست-دیباگ-و-مستندسازی)
21. [انتشار، مجوزها و تنظیمات پلتفرم](#21-انتشار-مجوزها-و-تنظیمات-پلتفرم)
22. [حریم شخصی، اخلاق و مسائل حقوقی](#22-حریم-شخصی-اخلاق-و-مسائل-حقوقی)
23. [مثال‌های عملی و راهنمای پیاده‌سازی (workflows)](#23-مثالهای-عملی-و-راهنمای-پیادهسازی-workflows)
24. [قالب‌های داده (JSON) و نمونه‌ها](#24-قالبهای-داده-json-و-نمونهها)
25. [Planogram & Layout: رویکردها برای چیدمان](#25-planogram--layout-رویکردها-برای-چیدمان)
26. [مشکلات رایج و جعبه‌ابزار رفع اشکال](#26-مشکلات-رایج-و-جعبهابزار-رفع-اشکال)
27. [منابع جامع و کتاب‌شناسی](#27-منابع-جامع-و-کتابشناسی)
28. [واژه‌نامه (Glossary)](#28-واژهنامه-glossary)

---

# 1) مقدمه و تعاریف

**واقعیت افزوده (Augmented Reality — AR)** تکنولوژی‌ای است که عناصر دیجیتال را روی دنیای واقعی می‌نشاند به‌گونه‌ای که کاربر همزمان محیط واقعی و دادهٔ دیجیتال را مشاهده و با آن تعامل کند. این عناصر می‌توانند متن، تصویر ۲D، مدل سه‌بعدی، صوت یا حتی اطلاعات حسگری باشند.

**هدف این ویکی:** آموزش گام‌به‌گام برای تازه‌کارها، بدون پیش‌نیاز بالا؛ پوشش مفاهیم فنی، ابزارها، روش‌ها، نمونه‌کد و نکات عملی. پروژه‌ها می‌توانند آموزشی، تجاری یا پژوهشی باشند؛ مثال‌ها عمومی‌اند تا هر کاربر بتواند آن‌ها را برای نیاز خود تطبیق دهد.

> **نکته برای ارائه:** هرگاه در دفاع یا گزارش به AR اشاره می‌کنید، یک تعریف کوتاه و یک مثال کاربردی داخلِ یک پاراگراف کافی است.

---

# 2) تاریخچه مختصر و مسیر توسعه

- دههٔ 1960: ابتدای تحقیقات تصویری و اولین هدست‌ها (Ivan Sutherland).
- دههٔ 1990: توسعهٔ الگوریتم‌های اولیه ردیابی و SLAM در دانشگاه‌ها.
- اوایل دههٔ 2000: سیستم‌های MAR (Marker-based AR) و اپلیکیشن‌های آزمایشی.
- 2010s: ظهور گوشی‌های هوشمند؛ Google Glass؛ از 2017 به بعد ARKit و ARCore که AR موبایل را متحول کردند.
- 2020s: LiDAR و Depth API، گسترش WebAR و پلتفرم‌های تجاری.

**نتیجه‌گیری:** هر گام پیشرفت سخت‌افزار (دوربین، سنسورها، پردازنده‌ها) یا الگوریتم (SLAM، بینایی ماشین) قابلیت‌های عملی‌تر و کاربردی‌تری را فراهم کرده است.

---

# 3) تفاوت AR، VR و MR

**AR** — افزودن لایه‌های دیجیتال روی دنیای واقعی.  
**VR** — جایگزینی کامل دنیای واقعی با دنیای مجازی (غوطه‌وری).  
**MR (Mixed Reality)** — سطحی بالاتر از AR که تعاملات پیچیده‌تر بین اجسام واقعی و مجازی را ممکن می‌سازد (مثلاً فیزیک مشترک، occlusion دقیق).

**مثال کاربردی:** برای یک اپ آموزش چیدمان فروشگاه، AR مناسب است (نمایش قفسه و مسیر مشتری). اگر بخواهید شبیه‌سازی کامل یک انبار را بدون محیط واقعی داشته باشید، VR مناسب‌تر است.

---

# 4) انواع روش‌های AR

- **Marker-based AR:** نیاز به مارکر یا تصویر مرجع؛ پیاده‌سازی ساده و پایدار در شرایط استاندارد.
- **Markerless (SLAM-based) AR:** بدون مارکر، با استفاده از ویژگی‌های محیط و SLAM؛ مناسب برای موبایل و طراحی داخلی.
- **Image/Model Target:** شناسایی تصویر یا مدل مشخص (مانند بستهٔ محصول) و نمایش محتوا.
- **Location-based AR:** استفاده از GPS/Compass برای تجربه‌های محیط باز و گردشگری.
- **Projection-based AR:** پروجکت‌کردن محتوا روی سطوح فیزیکی (نمایشگاه‌ها، موزه).

**راهنما:** برای اپ‌های فروشگاهی داخلی، معمولاً Markerless + Plane Detection بهترین ترکیب است.

---

# 5) موارد استفاده (Use Cases)

**صنعتی و آموزشی:** آموزش تعمیر، دستورالعمل‌های کاری، جعبه ابزار مجازی.  
**خرده‌فروشی:** نمایش مجازی قفسه‌ها، تجربهٔ try-before-you-buy، هدایت مشتری داخل فروشگاه.  
**پزشکی:** آموزش آناتومی، کمک در جراحی.  
**معماری/دیزاین:** مشاهدهٔ مدل‌های ۳D روی سایت واقعی.  
**سرگرمی/تبلیغات:** بازی‌ها، کمپین‌های تبلیغاتی تعاملی.

**نکته:** هر Use Case نیازمند بررسی دقیق از جهت حریم خصوصی، دقت مورد نیاز و سخت‌افزار هدف است.

---

# 6) پیش‌نیازها و مهارت‌های لازم

- **برنامه‌نویسی:** C# (Unity)، Swift (iOS native)، Kotlin/Java (Android native).
- **مدل‌سازی سه‌بعدی:** Blender، شناخت LOD، UV mapping، تکسچرینگ.
- **ریاضیات پایهٔ ۳D:** بردار، ماتریس، کواترنیون، تبدیل‌ها (transform).
- **بینایی ماشین پایه:** فیچرها، توصیفگرها (ORB/SIFT)، مفاهیم SLAM.
- **مهارت‌های UX/UI:** طراحی تجربهٔ AR و ارائهٔ onboarding.
- **مدیریت پروژه/نسخه‌بندی:** Git و مستندسازی.

**چک‌لیست شروع:** نصب Unity LTS، نصب Blender (یا استفاده از مدل‌های آماده)، آشنایی با مفاهیم ترانسفورم.

---

# 7) سخت‌افزارها و سنسورها

### 7.1 موبایل و تبلت

- دوربین RGB، IMU (ژیروسکوپ/شتاب‌سنج)، گاهی ToF/Depth sensor.
- پشتیبانی توسط ARCore (Android) و ARKit (iOS).

### 7.2 هدست‌ها و نمایشگرها

- Microsoft HoloLens, Magic Leap — مناسب صنعت و آموزش.
- هدست‌های VR با passthrough برای برخی سناریوها.

### 7.3 LiDAR و Depth sensors

- عمق‌نگاری دقیق، اوکلوژن بهتر، نقشه‌برداری سریع‌تر.
- توجه: فقط در برخی مدل‌های پیشرفته موجود است.

### 7.4 تجهیزات جانبی

- مارکرها، کنترلرها، پروژکتورها.

**نکته عملی:** اگر برنامهٔ شما به دقت بالای ابعاد نیاز دارد (مثلاً نقشه‌برداری فروشگاه)، بهتر است حداقل برای تست یک دستگاه مجهز به LiDAR یا Depth API داشته باشید.

---

# 8) نرم‌افزارها، موتور‌ها و کتابخانه‌ها

### 8.1 Unity + AR Foundation (توصیه اصلی)

- قابلیت کراس-پلتفرم؛ پشتیبانی ARKit/ARCore؛ توسعهٔ سریع با C#.

### 8.2 Unreal Engine

- مناسب پروژه‌های با نیاز گرافیکی بالا؛ Blueprints برای توسعهٔ سریع بدون کدنویسی سنگین.

### 8.3 SDKهای تخصصی

- Vuforia (Image/Model Targets), Wikitude, 8th Wall (WebAR).

### 8.4 ابزارهای طراحی

- Blender, Substance Painter, Sketchfab برای مدل و متریال.

**راهنمای انتخاب:** برای بیشتر پروژه‌های آموزشی/تجاری کوچک و متوسط، Unity + AR Foundation بهترین ترکیب از سرعت توسعه و پشتیبانی را ارائه می‌دهد.

---

# 9) مفاهیم پایه فنی

- **Tracking:** Pose estimation (موقعیت و چرخش دوربین).
- **SLAM:** هم‌زمان‌سازی Localization و Mapping.
- **Coordinate spaces:** World, Local, Camera spaces — دقت در تبدیل‌ها (right-handed vs left-handed).
- **Anchors:** نقاط ثابت برای قرارگیری مدل.
- **Raycasting:** تعیین برخورد لمس یا پرتو با سطوح.
- **Feature points & point cloud:** نقاطی که SLAM برای نگاشت استفاده می‌کند.

**پیشنهاد عملی:** همیشه هنگام محاسبهٔ فاصله یا زاویه بین آبجکت‌ها، تبدیل مختصات را بررسی کنید تا اشتباهات محور ایجاد نشود.

---

# 10) معماری یک اپلیکیشن AR

یک معماری ساده و قابل توسعه معمولاً شامل لایه‌های زیر است:

- **Presentation / UI Layer:** UI شناور، منوها، راهنماها.
- **AR Engine Layer:** تعامل با AR Foundation / ARKit / ARCore.
- **Content Layer:** مدل‌ها، تکسچرها، داده‌های Planogram.
- **Data & Persistence Layer:** ذخیرهٔ نقشه، JSON، دیتاهای کاربر.
- **Business Logic:** الگوریتم‌های چیدمان، قوانین فروشگاهی.

**نمودار جریان ساده:**

```
Camera -> AR Engine (Tracking, Planes) -> Mapping Module -> Layout Engine -> Renderer/UI
```

**نکته:** منطق چیدمان (Layout Engine) باید مستقل از رابط AR نوشته شود تا قابلیت تست و اجرای آفلاین را داشته باشد.

---

# 11) راه‌اندازی محیط توسعه: Unity + AR Foundation (گام‌به‌گام)

**پیش‌نیاز:** Unity Hub، نسخهٔ LTS Unity (مثلاً 2022.x یا 2023.x بسته به سازگاری)، ماژول‌های Android/iOS.

### مراحل سریع

1. نصب Unity از Unity Hub با ماژول‌های Android/iOS support.
2. ایجاد پروژه جدید (3D یا URP).
3. Window → Package Manager → نصب `AR Foundation`، `ARCore XR Plugin`، `ARKit XR Plugin`.
4. تنظیم: Edit → Project Settings → XR Plug-in Management → فعال کردن ARCore/ARKit.
5. در صحنه: اضافه کردن `AR Session` و `AR Session Origin`، افزودن `AR Camera` و `AR Plane Manager`، `ARRaycastManager`.
6. اضافه‌کردن Prefab برای نمایش Planeها و Markerهای بصری.
7. Build Settings → انتخاب پلتفرم → Build and Run روی دستگاه.

### نکات عملی

- برای iOS نیاز به Mac و Xcode است.
- تست اولیه در Editor محدود است؛ تست نهایی **حتماً روی دستگاه واقعی** انجام شود.

---

# 12) نمونه‌کدها و الگوهای طراحی (C# برای Unity)

### 12.1 Tap to Place (Raycast و Instantiate)

```csharp
using UnityEngine;
using UnityEngine.XR.ARFoundation;
using UnityEngine.XR.ARSubsystems;
using System.Collections.Generic;

public class TapToPlace : MonoBehaviour
{
    public ARRaycastManager raycastManager;
    public GameObject prefab;
    static List<ARRaycastHit> hits = new List<ARRaycastHit>();

    void Update()
    {
        if (Input.touchCount == 0) return;
        var touch = Input.GetTouch(0);
        if (touch.phase != TouchPhase.Began) return;

        if (raycastManager.Raycast(touch.position, hits, TrackableType.Planes))
        {
            var hitPose = hits[0].pose;
            Instantiate(prefab, hitPose.position, hitPose.rotation);
        }
    }
}
```

### 12.2 Attach to Anchor (پایداری بیشتر)

```csharp
using UnityEngine;
using UnityEngine.XR.ARFoundation;

public class AnchorPlacer : MonoBehaviour
{
    public ARAnchorManager anchorManager;

    public GameObject markerPrefab;

    public void PlaceAnchor(UnityEngine.Pose pose)
    {
        var anchor = anchorManager.AddAnchor(pose);
        if (anchor != null)
        {
            Instantiate(markerPrefab, anchor.transform.position, anchor.transform.rotation, anchor.transform);
        }
    }
}
```

### 12.3 اندازه‌گیری فاصله بین دو نقطه (متر)

```csharp
float DistanceMeters(Transform a, Transform b)
{
    return Vector3.Distance(a.position, b.position);
}
```

> 🔧 **الگو:** بخش‌های AR و Layout Engine را از هم جدا نگه دارید؛ برای تست الگوریتمی Layout از شبیه‌سازی دوبعدیِ ساده استفاده کنید (بدون نیاز به AR).

---

# 13) مدیریت محتوا و مدل‌های سه‌بعدی

- **فرمت‌ها:** glTF/glb (سبک)، FBX (پشتیبانی Unity)، OBJ (ساده).
- **بهینه‌سازی:** LOD (Level of Detail)، Texture atlases، baking نور برای صحنه‌های ثابت.
- **روال واردسازی:** مدل → تنظیم Scale → ایجاد Prefab → تنظیم Collider/Material → اضافه به Addressables (برای بارگذاری دینامیک).

**نکته عملی:** برای موبایل از glTF یا FBX بهینه‌شده با سایز تکسچر ≤ 2048px استفاده کنید و تکسچرهای غیرقابل‌نیاز را پاک کنید.

---

# 14) طراحی تجربه کاربری (UX) برای AR

### اصول UX در AR

- **راهنمایی کاربر در اسکن محیط:** متن کوتاه + انیمیشن نشانگر (از کاربر بخواهید دستگاه را حرکت دهد).
- **بازخورد فوری:** نشانگر لبهٔ Plane، پیش‌نمایش مدل قبل از قرارگیری.
- **کنترل ساده:** یک یا دو انگشت برای تعامل (Pinch برای زوم، Rotate gesture برای چرخش).
- **اطلاعات کم اما مفید:** پنل‌‌های شناور مختصر، دکمه‌های مشخص.

### مثال Onboarding

1. پیام: «دوربین را آهسته حرکت دهید تا محیط شناسایی شود.»
2. نمایش گام‌به‌گام: حرکت دوربین، تایید Plane، انتخاب Prefab.
3. نکتهٔ مصرف باتری و راهنمای خروج از اسکن.

**قابلیت دسترسی:** رنگ‌ها و فونت‌ها را برای افراد کم‌بینا در نظر بگیرید؛ کنترل‌های صوتی یا بزرگنمایی برای تعامل بهتر.

---

# 15) الگوریتم‌های مکان‌یابی و نقشه‌برداری (SLAM و موارد مرتبط)

### SLAM انواع و نکات

- **Visual SLAM:** فقط با دوربین RGB روی نقاط فیچر کار می‌کند.
- **Visual-Inertial SLAM (VIO):** ترکیب دادهٔ دوربین و IMU برای استحکام بیشتر.
- **LiDAR SLAM:** استفاده از داده‌های عمق برای نقشه‌برداری دقیق‌تر.

### مشکلات رایج SLAM

- **Drift (انحراف):** خطای تجمعی در موقعیت نسبت به زمان. راهکار: loop closure و keyframe management.
- **Feature-poor environments:** دیوار سفید یا سطوح یکنواخت باعث افت عملکرد می‌شود — استفاده از markers یا texture اضافه.

**پیشنهاد:** برای محیط‌های داخلی فروشگاهی، ترکیب VIO با برخی Anchorهای دستی بهترین عملکرد را می‌دهد.

---

# 16) تشخیص سطوح (Plane Detection)، لنگرها (Anchors) و Raycasting

### Plane Detection

- **افقی (Horizontal)**: کف، میز
- **عمودی (Vertical)**: دیوار، کابینت

**تنظیمات مهم:** حداقل اندازهٔ plane برای ثبت، نمایش Debug gizmos برای کاربر.

### Anchors

- Anchorها برای پایداری مدل‌ها استفاده می‌شوند؛ اضافه‌شدن anchor به ARSubsystem باعث حفظ موقعیت منطبق بر دنیای واقعی می‌شود.

### Raycasting

- Raycast روی screen-space برای تشخیص لمس؛ Raycast روی physics برای برخوردهای فیزیکی.

**نکته:** همواره تعداد Anchorها را مدیریت کنید (پاک‌سازی Anchorهای بلااستفاده) تا حافظه و عملکرد حفظ شود.

---

# 17) اوکلوژن (Occlusion) و برآورد نور (Light Estimation)

### Occlusion

- هدف: طبیعی‌تر کردن صحنه با پنهان‌کردن بخش‌هایی از مدل که باید پشت اجسام واقعی قرار گیرند.
- روش‌ها:
  - استفاده از Depth API / LiDAR برای عمق واقعی
  - ساخت مش هندسی تقریباً مشابه از محیط برای اوکلوژن (در دستگاه‌های بدون LiDAR)

### Light Estimation

- APIهای ARKit/ARCore داده‌هایی نظیر ambient intensity و color temperature ارائه می‌دهند.
- استفاده: تنظیم متریال، ambient light، و سایه‌ها برای همخوانی با محیط.

**نکته عملی:** اوکلوژن نرم‌افزاری نیاز به trade-off بین کیفیت و عملکرد دارد؛ برای موبایل معمولاً از ماسک‌های عمق با رزولوشن پایین استفاده می‌شود.

---

# 18) کار با LiDAR و داده‌های عمق (Depth)

- LiDAR و ToF دادهٔ عمق دقیق ارائه می‌دهند که برای اوکلوژن، اندازه‌گیری و اسکن دقیق محیط بسیار مفید است.
- **روال:** گرفتن point cloud → فیلتر نوفه‌ها → تولید mesh یا voxel grid → استفاده برای collision/occlusion و اندازه‌گیری.
- **محدودیت:** همه دستگاه‌ها LiDAR ندارند؛ اپ باید graceful degradation داشته باشد (fallback به SLAM).

**مثال:** با LiDAR می‌توانید یک پلان دقیق از فروشگاه تولید کنید و Planogram را با دقت بالا اعمال کنید.

---

# 19) بهینه‌سازی عملکرد و ملاحظات حافظه

### تکنیک‌ها

- **LOD (Level of Detail):** چند نسخهٔ مدل با جزییات مختلف بارگذاری بر اساس فاصله.
- **Texture Atlasing:** ادغام تکسچرها برای کاهش draw calls.
- **Baking نور:** برای صحنه‌های ایستا استفاده کنید تا رندر سبک شود.
- **Batching و instancing:** برای اشیاء تکرارشونده (قفسه‌ها).
- **حداقل‌سازی GC allocations:** در Update loop از ساختن آبجکت‌های موقت پرهیز کنید.

### ابزارها

- Unity Profiler، Xcode Instruments، adb systrace.

**چک‌لیست بهینه‌سازی قبل از بیلد:** کاهش پلی‌گان‌ها، اندازهٔ تکسچرها، غیر فعال‌سازی لایتینگ گران‌قیمت، بررسی memory snapshots.

---

# 20) تست، دیباگ و مستندسازی

### تست

- تست روی حداقل 3–4 دستگاه با مشخصات متفاوت.
- تست تحت نور کم، نور قوی، سطوح بازتابی، حضور افراد.

### دیباگ

- Android: adb logcat
- iOS: Xcode Console, Instruments
- Unity: Remote device, Profiler, Development Build + Script Debugging

### مستندسازی

- نگهداری changelog، تست کیس‌ها، نمونهٔ JSONهای اسکن، عکس/ویدیوهای قبل/بعد از پیاده‌سازی.

**نکته عملی:** همیشه یک سناریو تست (Test Plan) بنویسید که موارد edge-case را شامل شود (درها بسته/باز، قفسه‌های شیشه‌ای، افراد در حال حرکت).

---

# 21) انتشار، مجوزها و تنظیمات پلتفرم

### Android

- minSdk و targetSdk مناسب، اضافه‌کردن permissionها (Camera).
- بررسی پشتیبانی ARCore برای مدل‌های هدف.

### iOS

- اضافه کردن `NSCameraUsageDescription` و توضیح استفاده (Info.plist).
- ساخت با Xcode و code signing.

### WebAR

- 8th Wall, model-viewer، محدودیت‌های cross-browser.

### فروش و توزیع

- Beta testing (TestFlight, Internal testing)، بررسی crash reports، تحویل نسخهٔ release.

---

# 22) حریم شخصی، اخلاق و مسائل حقوقی

- **مجوزها:** همیشه از کاربر اجازهٔ استفاده از دوربین را بگیرید و توضیح دهید داده‌ها چگونه استفاده و ذخیره می‌شوند.
- **حفظ داده‌ها:** ویدیو/عکس‌های ضبط‌شده را فقط در صورت نیاز ذخیره کنید و حتماً مکانیزم حذف و مدیریت داشته باشید.
- **ملاحظات اخلاقی:** جلوگیری از دنبال‌کردن ناخواسته افراد، عدم جمع‌آوری دادهٔ حساس، شفاف‌سازی اهداف جمع‌آوری داده.
- **قوانین محلی:** GDPR، CCPA یا قوانین محلی مربوطه را بررسی کنید.

**قالب متن اجازهٔ دسترسی (نمونه):**

> این اپ از دوربین برای اسکن محیط استفاده می‌کند. ویدیو یا عکس‌ها به‌صورت محلی ذخیره می‌شوند و بدون اجازهٔ صریح شما به سرور ارسال نمی‌شوند.

---

# 23) مثال‌های عملی و راهنمای پیاده‌سازی (workflows)

### Workflow A — اسکن سریع فضا و ایجاد نقشهٔ ساده

1. کاربر وارد حالت اسکن می‌شود و دوربین را آهسته حرکت می‌دهد.
2. ARPlaneManager سطوح را ثبت می‌کند.
3. کاربر گوشه‌ها/نقاط مرجع را تایید می‌کند (در صورت نیاز).
4. سیستم floor polygon را محاسبه می‌کند و خروجی JSON می‌سازد.

### Workflow B — قرار دادن قفسه پارامتریک و اختصاص دسته‌ها

1. انتخاب prefab قفسه با پارامترهای width/depth/height.
2. snap کردن به نرمال دیوار یا anchor.
3. اجرای الگوریتم چیدمان ساده (greedy) برای چینش و بررسی فاصله راهرو.
4. نمایش AR سه‌بعدی و امکان تایید/ویرایش دست کاربر.

**نکته:** Workflows را به بلوک‌های مستقل تقسیم کنید تا تست و توسعه آسان‌تر باشد.

---

# 24) قالب‌های داده (JSON) و نمونه‌ها

### نمونه JSON نقشهٔ فروشگاه

```json
{
  "storeId": "store_001",
  "units": "meters",
  "floorPolygon": [
    [0, 0],
    [6.2, 0],
    [6.2, 4.1],
    [0, 4.1]
  ],
  "walls": [
    { "from": 0, "to": 1 },
    { "from": 1, "to": 2 }
  ],
  "columns": [{ "id": "col_1", "center": [2.1, 1.7], "radius": 0.15 }],
  "shelves": [
    { "id": "s1", "pos": [1.0, 0.5], "rot": 90, "w": 1.2, "d": 0.4, "h": 2.0 }
  ]
}
```

### قالب ذخیرهٔ نتیجهٔ Layout

```json
{
  "layoutId":"layout_20250814",
  "shelves":[{"id":"s1","pos":[x,y,z],"rotation":0,"category":"snacks","priority":1}],
  "metrics":{"avgCustomerDistance":3.2,"aisleWidthMin":1.0}
}
```

**توصیه:** همیشه نسخهٔ اصلی (raw) و نسخهٔ human-readable را ذخیره کنید (برای Debug و Log).

---

# 25) Planogram & Layout: رویکردها برای چیدمان

### مفاهیم پایه

- **Planogram:** نقشهٔ تصویری جای‌گذاری کالاها روی قفسه.
- **اهداف:** حداکثرسازی دیده‌شدن کالا، دسترسی مشتری، افزایش cross-selling.

### قوانین ساده برای فروشگاه کوچک

- حداقل عرض راهرو: 0.9 متر
- ارتفاع دید چشم: 1.2–1.6 متر برای اقلام پرفروش
- اقلام سنگین پایین قفسه قرار گیرند

### الگوریتم پیشنهادی (Greedy با قیود)

```
Input: floorPolygon, shelvesList, categories with priority
1. identify usable walls and free floor area
2. sort shelves by width desc
3. for each shelf: try place along wall respecting aisleWidthConstraint
4. place island shelves in center ensuring circulation
5. assign categories per priority and evaluate metrics
Output: placement list + metrics
```

**نکته:** این الگوریتم پایه است؛ برای بهینه‌سازی واقعی می‌توان از metaheuristics یا ILP/QAP استفاده کرد.

---

# 26) مشکلات رایج و جعبه‌ابزار رفع اشکال

### مشکل: Plane پیدا نمی‌شود

- علت: نور کم، سطح ساده یا بازتابی
- رفع: افزودن texture/marker یا راهنمایی کاربر برای حرکت بیشتر

### مشکل: اشیاء می‌لرزند

- علت: drift یا anchor ضعیف
- رفع: استفاده از ARAnchorManager، اضافه کردن keyframeهای محلی

### مشکل: مقیاس اشتباه

- علت: واحدهای متفاوت (cm vs m) یا مدل غیرکالیبره
- رفع: ایجاد مرجع اندازه واحد در محیط (مثلاً A4 یا 30cm object)

### ابزارهای رفع اشکال

- Visual debugging: نمایش point cloud و feature points
- Logging: timestamped logs، snapshotهای JSON اسکن
- Recovery: امکان Reset session و Re-scan محدوده کوچک

---

# 27) منابع جامع و کتاب‌شناسی

- Unity AR Foundation docs — Unity Documentation
- ARCore developer guide — Google
- ARKit developer docs — Apple
- کتاب: _Augmented Reality for Developers_ (چند مرجع مشهور)
- مقالات پایه در حوزه SLAM و Visual-Inertial Odometry (VIO) — جستجو در IEEE/ACM و arXiv

---

# 28) واژه‌نامه (Glossary)

- **AR:** Augmented Reality — واقعیت افزوده
- **VR:** Virtual Reality — واقعیت مجازی
- **MR:** Mixed Reality — واقعیت ترکیبی
- **SLAM:** Simultaneous Localization And Mapping
- **Anchor:** نقطهٔ مرجع برای مدل‌ها
- **Plane:** سطح شناخته‌شده (floor/wall)
- **Raycast:** ارسال پرتو برای تشخیص برخورد
- **LOD:** Level of Detail
- **Occlusion:** پنهان‌سازی مدل پشت اشیاء واقعی
- **LiDAR:** Light Detection And Ranging — سنسور عمق
